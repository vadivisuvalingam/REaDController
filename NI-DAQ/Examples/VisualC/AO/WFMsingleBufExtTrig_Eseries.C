/*********************************************************************
*
* Example program: 
*    WFMsingleBufExtTrig_Eseries.c
*
* Description: 
*    Outputs a waveform from one analog output channel, upon an
*     external digital trigger, using internal timing (uses high-level
*     NI-DAQ functions, for E-series)
*
* Example Category: 
*    AO
*
* Example Task Types: 
*    BUF, 1CH, BURST, SYNC, INTTIM, EXTTRIG, ESER
*
* List of key parameters: 
*    ulIterations
*
*    [Since variables are hardcoded, there is no guarantee that this
*     program will work for your setup.  This example is simply
*     presented as a code snippet of how you can use NI-DAQ functions
*     to perform a task.]
*
* List of NI-DAQ Functions used in this example: 
*    Timeout_Config, NIDAQErrorHandler, NIDAQMakeBuffer, Select_Signal,
*     WFM_Scale, WFM_Op, AO_VWrite
*
*    [NOTE: For further details on each NI-DAQ function, please refer
*     to the NI-DAQ On-Line Help (NIDAQPC.HLP).]
*
* Pin Connection Information: 
*    The analog output signal will be available at AO channel 0. The
*     default analog output mode for the DAQ device will be used. Also,
*     connect a digital pulse train to the PFI6/WFTRIG pin.
*
*    [For further I/O connection details, please refer to your hardware
*     User Manual.]
*
*    [For further details on how to run this example, please refer to
*     the NI-DAQ Examples On-Line Help (NIDAQEx.HLP).]
*
*********************************************************************/
/*
 * Includes: 
 */

#include "nidaqex.h"


/*
 * Main: 
 */

void main(void)
{
    /*
     * Local Variable Declarations: 
     */

    i16 iStatus = 0;
    i16 iRetVal = 0;
    i16 iDevice = 1;
    i16 iNumChans = 1;
    i16 iChan = 0;
    static i16 piChanVect[1] = {0};
    static f64 pdBuffer[5000] = {0};
    static i16 piBuffer[5000] = {0};
    u32 ulCount = 5000;
    u32 ulIterations = 1;
    f64 dUpdateRate = 1000.0;
    i32 lTimeout = 180;
    i16 iIgnoreWarning = 0;

    /* This sets a timeout limit (#Sec * 18ticks/Sec) so that if there
     is something wrong, the program won't hang on the WFM_Op call. */
    

    iStatus = Timeout_Config(iDevice, lTimeout);

    iRetVal = NIDAQErrorHandler(iStatus, "Timeout_Config",
     iIgnoreWarning);

    iStatus = NIDAQMakeBuffer(pdBuffer, ulCount, WFM_DATA_F64);

    if (iStatus == 0) {


        /* If buffer was made correctly, then output it. */

        printf(" A %lu point waveform should be output at a rate of %lf updates/sec.\n", ulCount, dUpdateRate);

        /* Setup PFI lines for external waveform triggering. */
        

        iStatus = Select_Signal(iDevice, ND_OUT_START_TRIGGER,
         ND_PFI_6, ND_HIGH_TO_LOW);

        iRetVal = NIDAQErrorHandler(iStatus, "Select_Signal",
         iIgnoreWarning);

        printf(" Apply your digital trigger signal to PFI6 when ready.\n");

        iStatus = WFM_Scale(iDevice, iChan, ulCount, 1.0, pdBuffer,
         piBuffer);

        iRetVal = NIDAQErrorHandler(iStatus, "WFM_Scale",
         iIgnoreWarning);

        /* NOTE FOR DSA devices... DSA devices can format samples in a
         left-justified format in 32-bit data words. This means that the most
         significant bits of the data word contain the bits generated by the
         converter. When allocating data buffers, be sure to account for the
         32-bit data width. Even though a number of DAQ/SCAN/WFM functions are
         declared to accept pointers to 16-bit data buffers, you should pass
         pointers to 32-bit data buffers. */
        

        /* Also for DSA devices, remember to call AO_Change_Parameter
         to enable the analog output. */

        iStatus = WFM_Op(iDevice, iNumChans, piChanVect, piBuffer,
         ulCount, ulIterations, dUpdateRate);

        iRetVal = NIDAQErrorHandler(iStatus, "WFM_Op",
         iIgnoreWarning);

        /* Set output at 0 volts. */

        iStatus = AO_VWrite(iDevice, iChan, 0.0);

        printf(" The waveform generation is done!\n");

        /* CLEANUP - Don't check for errors on purpose. */

        /* Set PFI line back to initial state. */

        iStatus = Select_Signal(iDevice, ND_OUT_START_TRIGGER,
         ND_AUTOMATIC, ND_LOW_TO_HIGH);

    }
    else {

        printf(" The buffer was not made correctly. Check the parameters for NIDAQMakeBuffer.\n");

    }


    /* Disable timeouts. */

    iStatus = Timeout_Config(iDevice, -1);


}

/* End of program */
